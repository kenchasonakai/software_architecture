# 第3章 ソフトウェア設計で大切なSOLID原則を理解する

なぜSOLID原則を押さえることが、AIと協働する設計者に不可欠なのでしょうか？

前章では、設計の基本姿勢としてKISSとYAGNIを整理しました。これらは、私たちの思考をシンプルに保ち、無駄をなくすための、いわば心構えのようなものです。

本章では、さらに一歩進んで、より具体的で実践的なオブジェクト指向設計の原則であるSOLID原則について掘り下げていきます。SOLID原則は、ロバート・C・マーティン（通称Uncle Bob）が体系化したことで広く知られていますが、この「SOLID」という頭字語自体は、マイケル・フェザーズが2004年頃に提唱したものです。また、各原則の一部は、マーティン以前から存在していました（例えば、オープン・クローズ原則はベルトラン・メイヤー、リスコフの置換原則はバーバラ・リスコフによって提唱されています）。本章では、マーティンによってまとめられた、以下の5つの原則の頭文字をとったものを扱います。

-   S: Single Responsibility Principle（単一責任の原則）
-   O: Open-Closed Principle（開放/閉鎖の原則）
-   L: Liskov Substitution Principle（リスコフの置換原則）
-   I: Interface Segregation Principle（インターフェース分離の原則）
-   D: Dependency Inversion Principle（依存性逆転の原則）

これらの原則は、変更に強く、理解しやすく、再利用性の高いソフトウェアを構築するための、非常に強力な指針となります。

…とはいえ、言葉だけ見ると、少し難しく感じるかもしれません。そこで本章では、私たちにとって身近な「コピー機」を比喩モデルとして使い、SOLID原則を直感的に理解していくことにしましょう。オフィスにあるあの大きな箱は、実はソフトウェア設計の原則の宝庫なのです。

本章では、コピー機の各部品（読み取り部、印字部、給紙部など）と、それらがどのように協調動作するかを通じて、SOLID原則の本質を捉える視点を提示します。実務で使える具体的なコード例も交えながら、設計原則を体感的に掴めるよう構成しています。

## S: Single Responsibility Principle（単一責任の原則）

### 原則の説明

単一責任の原則は、「クラス（やモジュール、関数）を変更する理由は、一つだけであるべきだ」と述べています。

言い換えるなら、「一つのクラスは、一つの責任だけを持つべき」ということです。ここでいう「責任」とは、「ソフトウェアが提供する機能の一側面」と考えるとよいでしょう。

コピー機で例えてみましょう。コピー機は、大きく分けていくつかの部品から構成されています。

-   原稿読み取り部: ガラスの台に置かれた原稿をスキャンし、画像データに変換する責任を持つ。
-   印字部: 紙にトナーを転写し、画像を印刷する責任を持つ。
-   給紙部: 指定されたサイズの紙を、本体に供給する責任を持つ。
-   操作パネル部: ユーザーからの指示（コピー枚数、濃度など）を受け付ける責任を持つ。

これらの部品は、それぞれが明確に異なる「責任」を担っています。原稿読み取り部が、紙詰まりの心配をすることはありません。印字部が、原稿の読み取り方法を気にする必要もありません。

> クラスとして書き下すと、責務ごとに役割と手段が切り分けられていることが視覚的にわかります。

```text
class 原稿読み取り部
  役割: 読み取る(原稿ID) → 画像データ
  手段: スキャナ装置から指定された原稿IDの画像を取得する
end

class 印字部
  役割: 印字する(画像データ, 用紙設定)
  手段: プリンタ装置へ画像データと用紙設定を渡し印刷を実行する
end

class コピー機本体
  役割: 実行(原稿ID, 用紙設定)
  手段: 読み取り部と印字部に処理を委譲し結果を組み合わせる
end
```

### なぜ重要か

もし、この責任の分離ができていなかったらどうなるでしょうか。例えば、原稿の読み取りと印刷を、一つの巨大な「コピー実行部」という部品が担当していたとします。

この場合、「新しいスキャン技術に対応して、読み取り精度を向上させたい」という変更要求が来たとします。開発者は、「コピー実行部」を修正しますが、その修正が、意図せず印刷処理のロジックに影響を与え、これまで発生しなかった印刷エラーを引き起こしてしまうかもしれません。読み取りと印刷という、全く異なる2つの変更理由が、同じクラスに存在してしまっているからです。

責任を単一にすることで、以下のようなメリットが生まれます。

-   変更の影響範囲が限定される: 読み取り方式の変更は「原稿読み取り部」のクラスだけを修正すればよく、他のクラスへの影響を心配する必要がありません。
-   テストが容易になる: 各クラスが持つ責任が明確なため、テストコードも書きやすくなります。
-   再利用しやすくなる: 例えば、「原稿読み取り部」は、コピー機能だけでなく、「スキャンしてメールで送信する」という別の機能でも再利用できるかもしれません。

AIとの協調においても、この原則は極めて重要です。「原稿読み取り部に、自動色補正機能を追加して」というように、責任の所在が明確であれば、AIへの指示もまた明確になり、AIは適切なクラスに適切なコードを生成してくれるでしょう。

#### 良い例: 責任を分けた構成

```text
class 原稿読み取り部
  役割: 読み取る(原稿ID) → 画像データ
  手段: スキャナ装置から指定された原稿IDの画像を取得する
end

class 印字部
  役割: 印字する(画像データ, 用紙設定)
  手段: プリンタ装置へ画像データと用紙設定を渡し印刷を実行する
end

class コピー機本体
  役割: 実行(原稿ID, 用紙設定)
  手段: 構築時に原稿読み取り部と印字部を受け取り保持し、
        実行時は読み取り部で画像データを取得後に印字部へ委譲する
end
```

変更理由ごとにクラスが分かれているため、AIに生成を依頼するときも「読み取り部のノイズ除去を改善して」と、対象を明言できます。

#### 悪い例: 万能本体の暴走

```text
class 万能コピー機本体
  def execute(原稿ID, 用紙設定)
    画像 = スキャナ装置から画像を取得する(原稿ID)
    補正済み画像 = 内蔵画像補正ロジックで補正する(画像)
    プリンタ装置へ出力指示を送信する(補正済み画像, 用紙設定)
    ログサービスに見積もりログを登録する(原稿ID, 用紙設定)
  end
end
```

読み取りも印字もログ記録も一つのクラスに押し込めてしまうと、どの変更でも `万能コピー機本体` を編集せざるを得なくなります。単一責任の原則に反する設計は、AIが生成したコードの差分を見極める際にも障害になります。

## O: Open-Closed Principle（開放/閉鎖の原則）

### 原則の説明

開放/閉鎖の原則は、「ソフトウェアのエンティティ（クラス、モジュールなど）は、拡張に対しては開いており、修正に対しては閉じているべきだ」と述べています。

これは、既存の動いているコードには手を加えることなく、システムの振る舞いを変更・拡張できるような設計を目指すべきだ、という意味です。

再び、コピー機で考えてみましょう。ある日、オフィスで「A3サイズの紙にも印刷したい」という要望が上がりました。このとき、理想的なのは、コピー機本体のプログラムを一切書き換えることなく、新しく「A3対応給紙ユニット」という部品を追加するだけで、A3印刷が可能になることです。

これが、「拡張に対して開いている」状態です。新しい機能（A3対応）を追加できます。

一方、このA3対応のために、コピー機本体の既存のソースコードを直接修正する必要があったとしたら、どうでしょうか。その修正が、既存のA4印刷機能にバグを埋め込んでしまうかもしれません。開放/閉鎖の原則は、このようなリスクを避けるため、既存のコードは「修正に対して閉じている」べきだと主張します。

※注記: とはいえ「いつか拡張するかもしれないから」と初期段階から複雑な抽象やパターンを盛り込み過ぎると、YAGNI（You Aren't Gonna Need It）の原則に反し、不要な設計コストだけが先行します。ひとまず必要な具体実装で出発し、同種の変更が繰り返される兆しを捉えたタイミングで拡張ポイントを抽象化し直す――そんな軽い構えで段階的に開放/閉鎖の原則へ寄せるのが実務では現実的です。

### どう実現するのか

この原則を実現する鍵は、「抽象」にあります。具体的には、インターフェースや抽象クラスを活用します。

コピー機本体は、「具体的なA4給紙ユニット」や「具体的なA3給紙ユニット」に直接依存するのではなく、もっと抽象的な「給紙ユニットインターフェース」にのみ依存するように設計します。

このインターフェースには、例えば `getPaper()` や `isPaperAvailable()` といった、給紙ユニットとして最低限必要な操作が定義されています。A4給紙ユニットも、新しく追加するA3給紙ユニットも、この同じインターフェースを実装します。

コピー機本体は、どの給紙ユニットが接続されても、この共通のインターフェースを通じて操作するだけです。そのため、新しいユニットが追加されても、本体側は一切コードを変更する必要がないのです。

ソフトウェアの例で言えば、決済処理システムが良い例です。`PaymentMethod` というインターフェースを定義し、`CreditCardPayment` や `BankTransferPayment` がそれを実装します。将来、`QRCodePayment` という新しい決済方法が追加されても、`PaymentMethod` インターフェースを実装しさえすれば、システムの他の部分を修正することなく、新しい決済方法に対応できます。

#### 良い例: 差し替え可能な給紙ユニット

```text
class 給紙ユニット
  役割: 次の用紙() → 用紙設定
  手段: 抽象メソッドとして定義し具体クラスに実装を委ねる
end

class A4給紙ユニット < 給紙ユニット
  役割: 次の用紙() は A4 の用紙設定を返す
end

class A3給紙ユニット < 給紙ユニット
  役割: 次の用紙() は A3 の用紙設定を返す
end

class コピー制御
  役割: 実行()
  手段: 構築時に注入された給紙ユニットへ次の用紙()を委頼し印字部へ渡す
end
```

コピー制御は `給紙ユニット` という抽象に対してのみ安定しており、新しい給紙方式を追加しても本体の修正は不要です。

#### 悪い例: 条件分岐だらけの本体

```text
class 条件分岐コピー制御
  def execute(モード種別)
    if モード種別 == :a4
      A4給紙ユニット.new.次の用紙()
    elsif モード種別 == :a3
      A3給紙ユニット.new.次の用紙()
    else
      raise "未知のモード"
    end
    # 新しいモードが増えるたびに条件分岐と呼び出し先を追加する羽目になる
  end
end
```

本体の条件分岐を増やしてしまうと、新しいサイズを追加するたびに本体コードを変更する必要が出てきます。開放/閉鎖の原則を守ることで、AIにも「新しい給紙ユニットを追加するだけで良い」と伝えられるのです。

## L: Liskov Substitution Principle（リスコフの置換原則）

### 原則の説明

リスコフの置換原則は、「派生型は、その基底型と置換可能でなければならない」と述べています。

これは、開放/閉鎖の原則で触れた「抽象」と「継承」を、より正しく使うための原則です。あるクラス（基底型）を継承したクラス（派生型）は、基底型の代わりに使っても、プログラムの振る舞いを変えてはならない、という意味です。

コピー機の例で言えば、前述の「給紙ユニットインターフェース」が基底型にあたります。これを実装した「A4給紙ユニット」や「A3給紙ユニット」が派生型です。コピー機本体から見れば、どちらのユニットが接続されても、「紙を供給する」という基本的な役割（契約）を同じように果たしてくれるはずです。これが、リスコフの置換原則が守られている状態です。

### なぜ重要か

もし、この原則が破られるとどうなるでしょうか。例えば、新しく「手差しトレイユニット」という派生型を追加したとします。しかし、このユニットだけは、紙がなくなったときに `isPaperAvailable()` が `false` を返すのではなく、特殊なエラー（例外）を投げるような実装になっていたとします。

コピー機本体は、そんな特殊な振る舞いを想定していません。そのため、ユーザーが手差しトレイを使ったときだけ、システムが予期せぬエラーで停止してしまうかもしれません。派生型が基底型と「置換不可能」だったために、問題が発生したのです。

リスコフの置換原則を守るということは、継承関係にあるクラス群が、同じ「契約」を守ることを意味します。これにより、クライアント（コピー機本体）は、安心して抽象（給紙ユニットインターフェース）に依存することができるのです。

#### 良い例: 契約を守る派生型

```text
class 読み取りヘッド
  役割: 読み取る() → 画像データ
  役割: キャリブレーション() → 調整を実施
  手段: 抽象メソッドとして定義し具体クラスに振る舞いを任せる
end

class CCD読み取りヘッド < 読み取りヘッド
  手段: 読み取る() は CCDセンサーで画像を取得し、キャリブレーション() は CCDの校正機能を呼び出す
end

class CIS読み取りヘッド < 読み取りヘッド
  手段: 読み取る() は CISセンサーで画像を走査し、キャリブレーション() は CISの調整機能を呼び出す
end
```

基底インターフェースに定義された操作を、派生型が同じ意味で提供しているため、コピー機本体はどちらの読み取りヘッドが注入されても同じ期待値で動作します。

#### 悪い例: 例外を投げる派生型

```text
class 手差し読み取りヘッド < 読み取りヘッド
  役割: 読み取る() → 例外を投げてしまう
  役割: キャリブレーション() → 何も実行しない
  手段: 基底の契約を破り、読み取る()で想定外の例外を発生させ、
        キャリブレーション()も空実装のまま放置している
end
```

この派生型は、基底の契約で保証された「読み取る」操作を破り、呼び出し側に想定外の例外を投げています。リスコフの置換原則が満たされていないと、AIが提案した差し替え案を採用した途端に本番障害を招くリスクがあります。

## I: Interface Segregation Principle（インターフェース分離の原則）

### 原則の説明

インターフェース分離の原則は、「クライアントに、自身が使わないメソッドへの依存を強制してはならない」と述べています。

これは、一つの巨大なインターフェースを作るのではなく、クライアントのニーズに応じて、インターフェースを小さく、具体的に分割すべきだ、という原則です。

コピー機の「仕上げ機能」を考えてみましょう。最近の多機能なコピー機には、印刷した紙をホチキスで綴じる「ステープル機能」、二つ折りにする「折り機能」、ファイリング用の「穴あけ機能」などが付いています。

ここで、これらの機能をすべて含んだ、一つの巨大な `FinishingUnit` インターフェースを設計したとします。

```text
class FinishingUnit
  def 綴じる
    raise NotImplementedError
  end

  def 折る
    raise NotImplementedError
  end

  def 穴を開ける
    raise NotImplementedError
  end
  # すべての仕上げ機能を一つに詰め込み、利用側に不要な操作まで押しつけている
end
```

この設計には問題があります。例えば、「ステープル機能だけを持つ、シンプルな仕上げユニット」を開発する場合、このユニットは `fold()` や `punch()` といった、自身が持たない機能のメソッドまで実装しなければなりません。中身を空にしたり、エラーを投げたりといった、不自然な実装を強制されることになります。

### どう実現するのか

インターフェース分離の原則は、このような「太ったインターフェース」を分割することを推奨します。

```text
class Stapler
  役割: 綴じる()
  手段: 抽象メソッドとして定義しステープル実装クラスに処理を委ねる
end

class Folder
  役割: 折る()
  手段: 抽象メソッドとして定義し折り実装クラスに処理を委ねる
end

class Puncher
  役割: 穴を開ける()
  手段: 抽象メソッドとして定義しパンチ実装クラスに処理を委ねる
end
```

このようにインターフェースを機能ごとに分離すれば、「ステープル機能だけを持つユニット」は `Stapler` インターフェースだけを実装すればよくなります。クライアント側も、本当に必要な機能のインターフェースにのみ依存することができます。

```text
class ステープルユニット < Stapler
  役割: 綴じる()
  手段: ホチキス機構を呼び出し用紙を綴じる処理を実行する
end

class 仕上げ制御
  役割: 綴じ処理()、パンチ処理()
  手段: 構築時に必要な仕上げ契約を任意で受け取り、
        綴じ処理ではStaplerがあれば綴じる()を呼び出し、不要な機能には依存しない
end
```

依存先を機能ごとに選べるため、AIに「パンチ機能だけを追加して」と頼むと `Puncher` 実装と配線の追加だけで済むようになります。

単一責任の原則がクラスの責任を分離する原則だったのに対し、インターフェース分離の原則はインターフェースの責任を分離する原則と考えることができます。

## D: Dependency Inversion Principle（依存性逆転の原則）

### 原則の説明

依存性逆転の原則は、SOLID原則の集大成とも言える、非常に重要な原則です。依存性逆転の原則は、2つのことを主張しています。

1.  上位モジュールは、下位モジュールに依存してはならない。両者とも、抽象に依存すべきである。
2.  抽象は、詳細に依存してはならない。詳細は、抽象に依存すべきである。

「上位モジュール」とは、ビジネスロジックの中核を担う、より抽象度の高いモジュールです。コピー機で言えば、「コピー処理全体を制御する本体」がこれにあたります。「下位モジュール」とは、具体的な実装を提供する、より詳細なモジュールです。「レーザーで印刷する印字部」や「CCDセンサーで読み取る原稿読み取り部」などが該当します。

伝統的なプログラムでは、上位モジュールが下位モジュールを直接呼び出す形で、依存関係が作られがちです（コピー機本体 → レーザー印字部）。しかし、この構造では、下位モジュール（印字部）を「インクジェット方式」に変更しようとすると、上位モジュール（本体）のコードまで修正する必要が出てきてしまいます。

### 依存性の「逆転」

依存性逆転の原則は、この依存関係の方向を「逆転」させます。

コピー機本体（上位モジュール）は、具体的な「レーザー印字部」ではなく、抽象的な「印字部インターフェース」にのみ依存します。そして、具体的な「レーザー印字部」や「インクジェット印字部」（下位モジュール）もまた、同じ「印字部インターフェース」を実装（依存）します。

これにより、依存関係の流れは「具象 → 抽象」となり、上位モジュールと下位モジュールの両方が、中心にある「抽象」に依存する形になります。この構造であれば、印字部の実装がレーザーからインクジェットに変わっても、上位モジュールであるコピー機本体は、何の影響も受けません。

この原則を実現する具体的なテクニックが、依存性注入（Dependency Injection） です。コピー機本体は、自身で「レーザー印字部」のインスタンスを生成するのではなく、外部から「印字部インターフェースを実装した、何らかのインスタンス」を注入される形で受け取ります。これにより、上位モジュールと下位モジュールの疎結合が実現されるのです。

#### 良い例: 抽象に依存する本体

```text
class 印字部
  役割: 印字する(画像データ, 用紙設定)
  手段: 抽象メソッドとして定義し具体クラスが印字方式を決める
end

class レーザー印字部 < 印字部
  手段: 印字する() ではレーザー方式の印字機構に処理を委ねる
end

class インクジェット印字部 < 印字部
  手段: 印字する() ではインク噴射方式の印字機構に処理を委ねる
end

class コピー機本体
  手段: 構築時に印字部(抽象)を受け取り、実行時は保持している印字部へ印字する()を依頼するだけで完結させる
end
```

本体が印字部の抽象にのみ依存しているため、新しい印字方式の採用は差し替えだけで完了します。

#### 悪い例: 具象に縛られた本体

```text
class 密結合コピー機本体
  def initialize
    @printer = レーザー印字部.new
  end

  def execute(画像データ, 用紙設定)
    @printer.印字する(画像データ, 用紙設定)
    # 印字方式を変えるたびに初期化や処理を本体側で書き換える必要が出てくる
  end
end
```

具象クラスを直接生成・操作してしまうと、印字方式を変えるたびに本体の修正が必要になります。依存性逆転の原則に反する設計は、AIに「インクジェット対応して」と依頼した際に、本体の大改修を誘発します。

## まとめ

本章では、SOLID原則という、堅牢で柔軟なソフトウェアを設計するための5つの柱について、コピー機を例に解き明かしました。

-   単一責任の原則: クラスの責任を一つに絞り、変更に強くする。
-   開放/閉鎖の原則: 抽象を利用し、修正ではなく拡張で機能追加に対応する。
-   リスコフの置換原則: 継承の「契約」を守り、置換可能性を保証する。
-   インターフェース分離の原則: インターフェースを適切に分割し、無駄な依存をなくす。
-   依存性逆転の原則: 抽象に依存することで、モジュール間の結合を疎にする。

これらの原則は、互いに深く関連し、補完しあっています。そして、これらの原則に従って設計されたコードは、責任の所在が明確で、モジュール間の関係性が整理されているため、人間だけでなく、AIにとっても非常に「理解しやすい」ものとなります。

AIに「新しい仕上げ機能として、パンチ機能を追加して」と依頼したとき、AIは `Puncher` インターフェースを実装した新しいクラスを作成し、DIコンテナに登録する、といった具体的な作業を正確に実行してくれるでしょう。これもすべて、SOLID原則によって、拡張すべき場所と方法が明確に定義されているからに他なりません。

もちろん、すべてのコードに、常に厳格にSOLID原則を適用する必要はありません。プロジェクトの規模や状況に応じて、その適用度を判断することもまた、重要な設計スキルです。

例えば、状況別に次のような優先順位を意識すると判断しやすくなります。

- スタートアップ初期: まずは単一責任の原則と依存性逆転の原則で差し替えやすさを確保し、他の原則はプロダクトマーケットフィット後に拡張する。
- エンタープライズ大規模開発: 全原則を明文化し、レビューでチェックリスト化しておく。
- プロトタイプやPoC: KISSと単一責任の原則の遵守を最低ラインとし、開放/閉鎖の原則とリスコフの置換原則は追加フェーズで整える。

さて、本書で扱う設計原則は、これが最後です。最終章となる「おわりに」では、これまで整理してきた内容を振り返り、AIと共に歩む未来のエンジニア像について考えていきましょう。
