# 第2章 ソフトウェア設計で意識しておくこと

なぜ「優れた設計」と「シンプルさ」は切り離せないのでしょうか？

優れた設計と聞くと、何か複雑で、高度な技術を駆使したものを想像するかもしれません。しかし、本当に優れた設計の多くは、驚くほど「シンプル」です。前章で、良い設計は人間にもAIにも理解しやすい、という話をしました。その「理解しやすさ」の根幹をなすのが、今回紹介する2つの基本原則です。

本章では、ソフトウェア設計の基本となる2つの考え方、KISS原則とYAGNI原則を整理します。

- KISS: Keep It Simple, Stupid（シンプルに保て、この間抜け）
- YAGNI: You Aren't Gonna Need It（どうせそれは必要にならない）

これらの原則は、一見すると当たり前のように聞こえるかもしれません。しかし、日々の開発の中で意識し続けることは、意外と難しいものです。なぜこれらが重要で、どうすれば実践できるのかを、具体的に見ていきましょう。

## KISS原則：シンプルさの価値

### KISS原則とは

KISS原則は、ロッキード・スカンクワークスの航空機設計者クラレンス・"ケリー"・ジョンソンが第二次世界大戦中に考案し、1960年代にアメリカ海軍で文書化された設計思想です。「Keep It Simple, Stupid」という少し乱暴な言葉には、「設計は、愚か者でも理解・修理できるくらいシンプルにしておけ」という、実用性を突き詰めた思想が込められています。

ソフトウェア開発において、この原則は「複雑さは敵であり、シンプルさは味方である」というメッセージとして解釈できます。不必要な複雑さを避け、可能な限り物事を単純に保つことが、結果として良いソフトウェアにつながる、という考え方です。

### なぜシンプルさが重要か

複雑なコードは、プロジェクトに様々な問題をもたらします。

1.  理解が難しい: コードの構造が複雑だと、新しく参加したメンバーが仕様を理解するのに時間がかかります。これは、AIがコードの文脈を理解する上でも同様の障壁となります。
2.  保守が難しい: 小さな仕様変更のつもりが、複雑に絡み合った依存関係のせいで、広範囲な修正を要求されることがあります。バグの原因特定も困難になり、「触らぬ神に祟りなし」と、誰もがそのコードに触れることを恐れるようになります。
3.  テストが難しい: コードの経路が複雑になればなるほど、テストケースは指数関数的に増加します。結果としてテストが不十分になり、品質の低下を招きます。

例えば、あるWebサービスのユーザー権限管理機能を考えてみましょう。

-   複雑な設計: 10種類以上の細分化された権限レベル、特定の条件下でのみ適用される複雑な権限の継承ルール、部署や役職に応じた無数の例外処理…。初期の要求をすべて満たそうとした結果、誰も全体像を把握できない「秘伝のタレ」のようなシステムが完成します。
-   シンプルな設計: 「閲覧者」「編集者」「管理者」という3つの基本的な役割（ロール）を定義します。権限は個人ではなく、この役割に紐づけます。例外を作らず、すべての権限管理がこの一貫したルールに基づいて行われるようにします。

後者のシンプルな設計は、前者ほどきめ細やかな制御はできないかもしれません。しかし、誰にとっても理解しやすく、将来「新しい役割」を追加することも容易です。AIに対して「編集者に、記事の公開権限を追加して」と指示するのも、非常に明快になります。

### KISS原則の実践方法

では、どうすればコードをシンプルに保てるのでしょうか。

1.  一つのことを、うまくやる: 関数やクラス、モジュールには、単一の責任だけを持たせましょう。「ユーザー情報を取得して、CSV形式で出力する」関数ではなく、「ユーザー情報を取得する」関数と「ユーザー情報のリストをCSV形式で出力する」関数の2つに分けるのです。これは、次章で扱うSOLID原則の「単一責任の原則」にも通じる考え方です。

2.  早すぎる抽象化を避ける: プログラマは、しばしばコードの重複を嫌い、すぐに共通化や抽象化を行おうとします。しかし、時期尚早な抽象化は、かえって設計を複雑にすることがあります。有名な法則に「Rule of Three（三度目の法則）」というものがあります。同じようなコードが3回現れるまでは、無理に抽象化せず、具体的な実装のままにしておく、という経験則です。これにより、本当に必要な、適切な抽象化を見極めることができます。

3.  「説明できるか？」テスト: あなたが書いたコードの設計を、他のエンジニアに5分で説明できるでしょうか？あるいは、ホワイトボードに図を描かずに、その仕組みを口頭で伝えられるでしょうか？もし、うまく説明できないのであれば、それは設計が複雑すぎるサインかもしれません。

## YAGNI原則：必要十分の設計

### YAGNI原則とは

YAGNIは、「You Aren't Gonna Need It」の頭文字をとったもので、「どうせそれは必要にならない」と訳されます。これは、アジャイル開発手法の一つであるエクストリーム・プログラミング（XP）から広まった考え方です。

その核心的なメッセージは、「今、必要であることが明確になっていない機能は、実装してはならない」というものです。将来必要になるかもしれない、という憶測に基づいて、先行して機能を実装することを戒める原則です。

### なぜYAGNIが重要か

良かれと思って行った「将来のための」実装は、しばしばプロジェクトの足かせとなります。

1.  無駄なコストの発生: 結局使われなかった機能の開発に費やした時間、その機能をテストし、メンテナンスし続けた時間は、すべて無駄になります。
2.  設計の複雑化: 「もしかしたら必要になるかも」という機能が積み重なることで、システムはどんどん複雑になります。本当に必要な機能が、使われない機能のノイズに埋もれてしまいます。
3.  変更への柔軟性の喪失: 開発者の立てた「将来の予測」は、驚くほど外れるものです。いざ仕様変更が必要になったとき、先行して実装した機能が前提となってしまい、かえって変更を困難にすることがあります。

例えば、ECサイトの決済機能を実装するケースを考えてみましょう。

-   過剰な実装（YAGNI違反）: 「将来的には様々な決済方法に対応できるように」と考え、クレジットカード、銀行振込、コンビニ決済、電子マネーなど、10種類の決済方法を扱えるような、非常に抽象的で複雑な決済基盤を最初に構築する。しかし、実際にローンチ時に必要なのはクレジットカード決済だけだったため、開発は大幅に遅延する。
-   適切な実装（YAGNI遵守）: まずはクレジットカード決済機能だけを、シンプルに実装してリリースする。ただし、将来の拡張に備えて、決済処理部分を他のロジックから分離しておく、といった「拡張性への配慮」は行います。その後、ビジネスの要求に応じて、銀行振込機能、コンビニ決済機能と、一つずつ追加していきます。

この「責任の分離」は、コピー機の印字部を取り替え可能にする発想と同じです。決済の具体的な実装は後から差し替えられるようにしつつ、今必要な機能だけを実装するというバランスです。

```text
契約: 決済エンジン
  手続き 決済する(請求ID, 請求額) → 処理結果

実装: クレジットカード決済 ← 決済エンジン
  決済する(請求ID, 請求額) を呼び出すと、送信APIに処理を委ねる

装置: 決済コピー機
  構築時に「現在使う決済エンジン」を受け取って保持する
  実行(請求ID, 請求額)
    → 保持している決済エンジンへ決済する(請求ID, 請求額) を依頼
```

まずは `クレジットカード決済` だけを用意し、必要になった段階で `銀行振込決済` や `電子マネー決済` を追加実装すれば十分です。コピー機本体にあたる `決済コピー機` は、常に抽象に依存するため、拡張時も落ち着いて差し替えられます。

### YAGNIの実践と注意点

YAGNI原則は、「何も考えずに場当たり的に作れ」という意味ではありません。それは「今、必要な設計に集中する」ということです。

-   現在の要求に集中する: チームで合意された、確定済みの要求仕様だけを実装の対象とします。憶測や、「あると便利かもしれない」という思いつきでコードを書くのをやめましょう。
-   リファクタリングを前提とする: YAGNIを実践するには、「コードは後からでも改善できる」という信頼が不可欠です。十分なテストコードに守られていれば、将来の要求変更に応じて、既存のコードを安全に、かつ大胆にリファクタリング（設計改善）することができます。

### どこまで先を読むべきか

経験則として、次のような時間軸を目安にすると、YAGNIと拡張性の両立がしやすくなります。

- データモデルはおよそ3か月先までの変更想定に留める。
- APIやUIの仕様は1か月先の確定したロードマップまでを考慮する。
- インフラ構成は現在の利用量と、次の大きなリリースで必要になる規模までを根拠に判断する。

YAGNIと設計のバランスは重要です。例えば、決済処理の例で言えば、「決済」という概念をインターフェースとして定義しておくことは、将来の拡張性を担保する良い設計であり、YAGNI違反にはあたりません。しかし、そのインターフェースの具体的な実装クラスを、今必要ないものまで作ってしまうのがYAGNI違反です。

## KISSとYAGNIの相乗効果

KISS原則とYAGNI原則は、互いに深く関連し、補完しあう関係にあります。

-   YAGNIは「何を作るか（What）」を決め、不要なものを削ぎ落とすことで、システム全体をシンプルに保ちます。
-   KISSは「どう作るか（How）」を決め、作るべきと決まったものを、最もシンプルな方法で実現することを目指します。

この2つを組み合わせることで、私たちは本当に価値のあるソフトウェアを、持続可能な形で開発していくことができます。AIとの協調においても、この相乗効果は絶大です。YAGNIによってタスクの範囲が明確になり、KISSによってその実現方法が明快になることで、AIへの指示もまた、この上なくシンプルで的確なものになるのです。

## まとめ

本章では、ソフトウェア設計の基本となる2つの原則、KISSとYAGNIを整理しました。

-   KISS: 複雑さを避け、物事を可能な限りシンプルに保つ。
-   YAGNI: 今、本当に必要なものだけに集中し、憶測で未来の機能を実装しない。

これらの原則は、あなたのコードを、そしてあなたの開発プロセスそのものを、より健全で、変化に強いものにしてくれるはずです。

KISSとYAGNIという基本原則を整理したうえで、次章では、より具体的なオブジェクト指向設計の原則であるSOLID原則を解説します。これらの原則を組み合わせることで、さらに堅牢で、保守しやすく、そしてAIとも協調しやすいソフトウェアを構築することができます。
